import json
import os
from pprint import pprint
from typing import Dict
import unicodedata
import requests
from InfoProviders.ThcInfoProvider.ThcOriginalTrackMapper.Model.OriginalTrackMapModel import OriginalTrack

IGNORE = {"地灵殿PH音乐名", "东方夏夜祭音乐名", "Cradle音乐名", "东方音焰火音乐名", "东方魔宝城音乐名", "8MPF音乐名"}

def map_line(line) -> dict:
    line = [i.strip() for i in line.split(",")]
    b = {
        "id": line[2],
        "type": line[1],
        "fullName": {
            "Default": unicodedata.normalize("NFKC", line[5]),
            "En": unicodedata.normalize("NFKC", line[3]),
            "Zh": unicodedata.normalize("NFKC", line[4]),
            "Jp": unicodedata.normalize("NFKC", line[5])
        },
        "shortName": {
            "Default": unicodedata.normalize("NFKC", line[8]),
            "En": unicodedata.normalize("NFKC", line[6]),
            "Zh": unicodedata.normalize("NFKC", line[7]),
            "Jp": unicodedata.normalize("NFKC", line[8])
        },
        "externalReference": line[0]
    }
    
    return {line[0]: b}

def load_original_album_map() -> Dict:
    path = input("Enter path to CSV with original track abbrivations (Generated by get-original-alb-trk.py): ") or r"D:\PROG\TlmcTagger\InfoProviderV3Pipeline\InfoProviders\ThcInfoProvider\ExternalData\TouhouAlbumV2.csv"
    if not os.path.isfile(path):
        print("Invalid path")
        exit(1)

    original_song_map = {}
    with open(path, "r", encoding="utf-8") as f:
        # skip header
        f.readline()
        for idx, line in enumerate(f):
            line = line.strip()
            if (not line):
                continue
            mapped = map_line(line)
            # print(f"Loaded: {list(mapped.keys())[0]}")
            original_song_map.update(mapped)

    return original_song_map

def map_track_attr(track: OriginalTrack, src_id: Dict) -> Dict:
    src_ext_ref = track.source.id
    # print(src_id[src_ext_ref])
    src_id = src_id[src_ext_ref]["id"]
    track_id = f"{src_id}-{track.index}"
    b = {
        "id": track_id,
        "title": {
            "default": unicodedata.normalize("NFKC", track.title_jp),
            "en": unicodedata.normalize("NFKC", track.title_en),
            "zh": unicodedata.normalize("NFKC", track.title_zh),
            "jp": unicodedata.normalize("NFKC", track.title_jp)
        }
    }
    return (src_id, b)

def load_tracks(album_map: Dict):
    loaded = {}
    for track in OriginalTrack.select(OriginalTrack, OriginalTrack.source).where(OriginalTrack.source.not_in(IGNORE)):
        src, map = map_track_attr(track, album_map)
        if src not in loaded:
            loaded[src] = []
        loaded[src].append(map)

    return loaded

def commit(album_map, track_map, track_add_ep, album_add_ep):
    for entry in album_map.values():
        album_id = entry["id"]
        print(f"Pushing album {album_id}")
        resp = requests.post(album_add_ep, json=entry, headers={"Content-Type": "application/json"})
        if resp.status_code != 201:
            print(f"Failed to create album {album_id}. {resp.json()}")
            continue

        for track in track_map[album_id]:
            print(f"Pushing track {track['id']}")
            resp = requests.post(track_add_ep.format(albumId=album_id), json=track, headers={"Content-Type": "application/json"})

            if resp.status_code != 201:
                print(f"Failed to create track {track['id']}. {resp.json()}")
                continue

if (__name__ == '__main__'):
    original_album_map = load_original_album_map()
    original_track_map = load_tracks(original_album_map)
    # pprint(original_track_map)
    # pprint(original_album_map)

    # write track map to json
    with open("original_track_map.json", "w", encoding="utf-8") as f:
        json.dump(original_track_map, f, ensure_ascii=False, indent=4)

    album_add_endpoint = input("Album CREATE endpoint: ") or "http://localhost:5217/api/source/album"
    track_add_endpoint = input("Track CREATE endpoint: ") or "http://localhost:5217/api/source/album/{albumId}/track"
    commit(original_album_map, original_track_map, track_add_endpoint, album_add_endpoint)
