from ctypes import Union
from genericpath import isfile
from operator import truediv
import os
from time import sleep
from typing import Dict
from Processor.ExternalInfoCollector.ThcInfoProvider.ThcOriginalTrackMapper.SongQuery import (
    SongQuery,
    get_original_song_query_params,
)
from Processor.ExternalInfoCollector.ThcInfoProvider.ThcSongInfoProvider.Model.ThcSongInfoModel import (
    Track,
    Album,
    ProcessStatus,
)
from Processor.ExternalInfoCollector.ThcInfoProvider.ThcSongInfoFomatter.Model.InfoFormattedModel import (
    AlbumFormatted,
    TrackFormatted,
    ProcessStatusFormatted,
)
import json


def load_original_song_map() -> Dict:
    path = (
        input(
            "Enter path to CSV with original track abbrivations (Generated by get-original-alb-trk.py): "
        )
        or r"D:\PROG\TlmcTagger\InfoProviderV3Pipeline\OriginalAlbums_Blank.csv"
    )
    if not os.path.isfile(path):
        print("Invalid path")
        exit(1)

    original_song_map = {}
    with open(path, "r", encoding="utf-8") as f:
        # skip header
        f.readline()
        for idx, line in enumerate(f):
            line = line.strip()
            if not line:
                continue
            data = line.split(",")
            id = data[0]
            abbriv = data[2]
            original_song_map[id] = abbriv
            print("[{}] Loaded {} -> {}".format(idx + 1, id, abbriv))

    return original_song_map


def map_title(at) -> Dict:
    title = {
        "default": at.title_jp,
        "en": at.title_en,
        "zh": at.title_zh,
        "jp": at.title_jp,
    }

    for k in list(title.keys()):
        if not title[k]:
            del title[k]
            continue
        if not title[k].strip():
            del title[k]

    return json.dumps(title)


def precheck():
    alb_no_title = (
        Album.select()
        .where(
            (Album.title_jp == None) & (Album.process_status != ProcessStatus.FAILED)
        )
        .count()
    )
    trk_no_title = Track.select().where(Track.title_jp == None).count()
    if alb_no_title > 0 or trk_no_title > 0:
        print(
            "Precheck failed: There are {} albums and {} tracks with no title".format(
                alb_no_title, trk_no_title
            )
        )
        c = input("Ignore Error and Continue?")
        if c.lower() != "y":
            exit(1)


def resolve_original_tracks(track: Track, abbriv_map: Dict):
    if not track.original:
        return []
    original = json.loads(track.original)
    query_params = get_original_song_query_params(original)
    org_tracks = []
    for qp in query_params:
        try:
            result = SongQuery.query(
                qp[0],
                qp[1],
                autofail={
                    "地灵殿PH音乐名",
                    "东方夏夜祭音乐名",
                    "Cradle音乐名",
                    "东方音焰火音乐名",
                    "东方魔宝城音乐名",
                    "8MPF音乐名",
                    "8MPF音乐名.",
                },
            )
        except:
            print("\n\n[ERROR] Failed to resolve original track: {}\n\n".format(qp))
            continue
        abbriv = abbriv_map[result.source.id]
        index = result.index
        org_tracks.append(f"{abbriv}-{index}")
    return json.dumps(org_tracks)


def configure_album(album: Album) -> AlbumFormatted:
    formatted = AlbumFormatted()
    formatted.album_id = album.album_id
    formatted.album_name = map_title(album)
    formatted.release_date = album.release_date
    formatted.catalogno = album.catalogno
    formatted.number_of_disc = album.number_of_disc
    formatted.website = album.website
    formatted.album_artist = album.album_artist
    formatted.data_source = album.data_source
    formatted.process_status = ProcessStatusFormatted.PROCESSED
    return formatted


def configure_track(
    album: AlbumFormatted, track: Track, abbriv_map: Dict
) -> TrackFormatted:
    formatted = TrackFormatted()
    formatted.album = album
    formatted.track_id = track.track_id
    formatted.title = map_title(track)

    formatted.index = track.index
    formatted.disc_no = track.disc_no
    formatted.vocal = track.vocal
    formatted.arrangement = track.arrangement
    formatted.circle = track.circle
    formatted.lyricist = track.lyrics_author

    formatted.original = resolve_original_tracks(track, abbriv_map)

    if track.src_track_not_th or track.src_album_not_th:
        formatted.original_non_touhou = True
    else:
        formatted.original_non_touhou = False

    formatted.process_status = ProcessStatusFormatted.PROCESSED
    return formatted


def import_data():
    precheck()
    abbriv_map = load_original_song_map()

    imported_album = []
    imported_track = []

    album: Album = None

    imp_alb_count = 0
    imp_trk_count = 0
    imp_mismatch_count = 0
    print("Selecting albums...")
    albums = (
        Album.select()
        .where(Album.process_status == ProcessStatus.PROCESSED & Album.title_jp != None)
        .execute()
    )
    print("Selected {} albums".format(len(albums)))
    for album in albums:
        tracks = Track.select().where(Track.album == album)
        # Do some checks
        basic_tracks = BasicTrack.select().where(BasicTrack.album == album.album_id)
        if any([t.title_jp == None for t in tracks]):
            print(f"\n\nTrack title missing for Album: {album.album_id}. Skipping\n\n")
            continue
        if len(basic_tracks) != len(tracks):
            imp_mismatch_count += 1
            print(
                f"\n\nTrack count mismatch for Album: {album.album_id} [Basic: {len(basic_tracks)} | Data: {len(tracks)}]\n\n"
            )
            import_album = AlbumFormatted()
            import_album.album_id = album.album_id
            import_album.data_source = album.data_source
            import_album.album_name = map_title(album)
            import_album.process_status = ProcessStatusFormatted.TRACK_COUNT_MISMATCH
            imported_album.append(import_album)
            continue

        imp_alb_count += 1
        import_album = configure_album(album)
        imported_album.append(import_album)
        for track in tracks:
            print(
                f"Imported {imp_alb_count} albums and {imp_trk_count} tracks [{imp_mismatch_count} mismatches]",
                end="\r",
            )
            imp_trk_count += 1
            import_track = configure_track(album, track, abbriv_map)
            imported_track.append(import_track)

    BATCH_SIZE = 1000
    for i in range(0, len(imported_album), BATCH_SIZE):
        print("Saving album {}/{}".format(i, len(imported_album)))
        AlbumFormatted.bulk_create(imported_album[i : i + BATCH_SIZE])

    for i in range(0, len(imported_track), BATCH_SIZE):
        print("Saving track {}/{}".format(i, len(imported_track)))
        TrackFormatted.bulk_create(imported_track[i : i + BATCH_SIZE])


if __name__ == "__main__":
    album_count = AlbumFormatted.select().count()
    track_count = TrackFormatted.select().count()
    if album_count == 0:
        import_data()
    else:
        print(
            f"There are already {album_count} albums and {track_count} tracks in the database"
        )
        print("Do you want to re-import the data? (y/n)")
        if input() == "y":
            # Delete all data
            print("Deleting all data...")
            AlbumFormatted.delete().execute()
            TrackFormatted.delete().execute()
            import_data()
        else:
            print("Exiting...")
            exit()
